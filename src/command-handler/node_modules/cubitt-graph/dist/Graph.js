"use strict";
var Common = require("cubitt-common");
var Collections = require("typescript-collections");
var NodeElement_1 = require("./NodeElement");
var EdgeElement_1 = require("./EdgeElement");
var ModelElement_1 = require("./ModelElement");
var ConnectorElement_1 = require("./ConnectorElement");
var ElementType_1 = require("./ElementType");
/**
 * Graph containing nodes, connectors, edges and models
 *
 * NOTICE: this class is used internally in the Project class, always use the Project class
 */
var Graph = (function () {
    function Graph() {
        this.elements = {};
    }
    /**
     * Returns an element given an GUID
     *
     * @param id GUID representing an element identifier
     */
    Graph.prototype.getElement = function (id) {
        var elem = this.elements[id.toString()];
        /* istanbul ignore if */
        if (elem === undefined) {
            /* istanbul ignore next */
            throw new Error("Element with GUID " + id.toString() + " not found");
        }
        return elem;
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.hasElement = function (id) {
        return this.elements[id.toString()] !== undefined;
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.hasModel = function (id) {
        var elem = this.elements[id.toString()];
        return elem !== undefined && elem.getType() === ElementType_1.ElementType.Model;
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.hasNode = function (id) {
        var elem = this.elements[id.toString()];
        return elem !== undefined && elem.getType() === ElementType_1.ElementType.Node;
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.hasConnector = function (id) {
        var elem = this.elements[id.toString()];
        return elem !== undefined && elem.getType() === ElementType_1.ElementType.Connector;
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.hasEdge = function (id) {
        var elem = this.elements[id.toString()];
        return elem !== undefined && elem.getType() === ElementType_1.ElementType.Edge;
    };
    /**
     * Removes an element from the graph, WARNING: does not perform a cascading delete (i.e. no removal of orphan edges)
     *
     * @param id Identifier of the element to remove
     * @param ofType Only delete the element if it is of the matching Type, if undefined, this check will be skipped
     */
    Graph.prototype.deleteElement = function (id, ofType) {
        if (ofType === undefined) {
            delete this.elements[id.toString()];
        }
        else {
            var elem = this.elements[id.toString()];
            if (elem !== undefined) {
                // It's fine if the elem did not exist (the endresult is the same)
                /* istanbul ignore if */
                if (elem.getType() !== ofType) {
                    throw new Error("Attempted to delete a " + elem.getType() + " with delete" + ofType.toString());
                }
                elem.delete(this);
            }
        }
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.addNode = function (id, type, modelId, properties) {
        /* istanbul ignore if */
        if (this.hasElement(id)) {
            throw new Error("An Element with GUID " + id.toString() + " already exists");
        }
        var model = this.elements[modelId.toString()];
        /* istanbul ignore if */
        if (model === undefined) {
            throw new Error("No model with GUID " + modelId + " could be found");
        }
        /* istanbul ignore if */
        if (model.getType() !== ElementType_1.ElementType.Model) {
            throw new Error("GUID " + modelId.toString() + " does not belong to a model");
        }
        /* istanbul ignore if */
        if (properties === null || properties === undefined) {
            properties = {};
        }
        properties["type"] = type;
        var node = new NodeElement_1.NodeElement(id, properties);
        node.addParentModelNeighbour(modelId);
        model.addChildNodeNeighbour(id);
        this.elements[node.Id.toString()] = node;
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.addEdge = function (id, type, modelId, startConnectorId, endConnectorId, properties) {
        if (properties === void 0) { properties = {}; }
        // Validate GUID
        /* istanbul ignore if */
        if (this.hasElement(id)) {
            throw new Error("An Element with GUID " + id.toString() + " already exists");
        }
        // Validate modelID
        var model = this.elements[modelId.toString()];
        /* istanbul ignore if */
        if (model === undefined) {
            throw new Error("No model with GUID " + modelId + " could be found");
        }
        /* istanbul ignore if */
        if (model.getType() !== ElementType_1.ElementType.Model) {
            throw new Error("Element with GUID " + modelId.toString() + " is not a Model");
        }
        // Validate startConnector
        var startConnector = this.elements[startConnectorId.toString()];
        /* istanbul ignore if */
        if (startConnector === undefined) {
            throw new Error("No startConnector with GUID " + startConnectorId + " could be found");
        }
        /* istanbul ignore if */
        if (startConnector.getType() !== ElementType_1.ElementType.Connector) {
            throw new Error("Invalid startConnectorId, " + startConnectorId + " does not belong to a connector");
        }
        // Validate endConnectorId
        var endConnector = this.elements[endConnectorId.toString()];
        /* istanbul ignore if */
        if (endConnector === undefined) {
            throw new Error("No endConnector with GUID " + endConnectorId + " could be found");
        }
        /* istanbul ignore if */
        if (endConnector.getType() !== ElementType_1.ElementType.Connector) {
            throw new Error("Invalid endConnectorId, " + endConnectorId + " does not belong to a connector");
        }
        /* istanbul ignore if */
        if (properties === null || properties === undefined) {
            properties = {};
        }
        properties["type"] = type;
        var edge = new EdgeElement_1.EdgeElement(id, properties);
        edge.addStartConnector(startConnectorId);
        edge.addEndConnector(endConnectorId);
        startConnector.addChildEdgeNeighbour(id);
        endConnector.addChildEdgeNeighbour(id);
        model.addChildEdgeNeighbour(id);
        edge.addParentModelNeighbour(modelId);
        this.elements[id.toString()] = edge;
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.addConnector = function (id, type, nodeId, properties) {
        // Validate GUID
        /* istanbul ignore if */
        if (this.hasElement(id)) {
            throw new Error("An Element with GUID " + id.toString() + " already exists");
        }
        // Validate nodeId exists
        var node = this.elements[nodeId.toString()];
        /* istanbul ignore if */
        if (node === undefined) {
            throw new Error("No node with GUID " + nodeId + " could be found");
        }
        /* istanbul ignore if */
        if (node.getType() !== ElementType_1.ElementType.Node) {
            throw new Error("Invalid nodeId, " + nodeId + " does not belong to a Node");
        }
        /* istanbul ignore if */
        if (properties === null || properties === undefined) {
            properties = {};
        }
        properties["type"] = type;
        var connector = new ConnectorElement_1.ConnectorElement(id, properties);
        node.addChildConnectorNeighbour(id);
        connector.addParentNodeNeighbour(nodeId);
        this.elements[id.toString()] = connector;
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.addModel = function (id, type, properties, parentId) {
        // Validate GUID
        /* istanbul ignore if */
        if (this.hasElement(id)) {
            throw new Error("An Element with GUID " + id.toString() + " already exists");
        }
        // If parentId is set validate it
        if (parentId !== null && parentId !== undefined) {
            // Validate if there is an node or edge with the provided GUID
            /* istanbul ignore if */
            if ((this.hasNode(parentId) || this.hasEdge(parentId)) === false) {
                throw new Error("No Node or Edge with GUID " + parentId.toString() + " could be found");
            }
        }
        /* istanbul ignore if */
        if (properties === null || properties === undefined) {
            properties = {};
        }
        properties["type"] = type;
        var model = new ModelElement_1.ModelElement(id, properties);
        // Attach it to parent if available
        if (parentId !== null && parentId !== undefined) {
            var parent_1 = this.getElement(parentId);
            parent_1.addChildModelNeighbour(id);
            if (this.hasEdge(parentId)) {
                model.addParentEdgeNeighbour(parentId);
            }
            if (this.hasNode(parentId)) {
                model.addParentNodeNeighbour(parentId);
            }
        }
        this.elements[id.toString()] = model;
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.setProperty = function (id, name, value) {
        /* istanbul ignore if */
        if (this.hasElement(id) === false) {
            throw new Error("An Element with GUID " + id.toString() + " could not be found");
        }
        this.elements[id.toString()].setProperty(name, value);
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.deleteNode = function (id) {
        this.deleteElement(id, ElementType_1.ElementType.Node);
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.deleteEdge = function (id) {
        this.deleteElement(id, ElementType_1.ElementType.Edge);
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.deleteConnector = function (id) {
        this.deleteElement(id, ElementType_1.ElementType.Connector);
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.deleteModel = function (id) {
        this.deleteElement(id, ElementType_1.ElementType.Model);
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.deleteProperty = function (id, name) {
        var elem = this.elements[id.toString()];
        /* istanbul ignore if */
        if (elem === undefined) {
            throw new Error("Element not found");
        }
        elem.deleteProperty(name);
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.deserialize = function (jsonObject) {
        var graph = new Graph();
        var models = jsonObject["models"];
        var queue = new Collections.Queue();
        var inQueue = {};
        // Find root models
        for (var modelKey in models) {
            var model = models[modelKey];
            if (Object.keys(model.neighbours.nodes.parent).length === 0 && Object.keys(model.neighbours.edges.parent).length === 0) {
                queue.enqueue({ "type": "model", "element": model.id.toString() });
                inQueue[model.id.toString()] = true;
            }
        }
        while (queue.isEmpty() === false) {
            var obj = queue.dequeue();
            var type = obj["type"];
            var elemId = obj["element"];
            var elem = jsonObject[type + "s"][elemId.toString()];
            var properties = this.propertiesFromJSON(elem["properties"]);
            switch (type) {
                case "model":
                    if (elem["neighbours"]["nodes"]["parent"].length > 0) {
                        graph.addModel(Common.Guid.parse(elem.id), properties["type"], properties, Common.Guid.parse(elem["neighbours"]["nodes"]["parent"][0]));
                    }
                    else if (elem["neighbours"]["edges"]["parent"].length > 0) {
                        graph.addModel(Common.Guid.parse(elem.id), properties["type"], properties, Common.Guid.parse(elem["neighbours"]["edges"]["parent"][0]));
                    }
                    else {
                        graph.addModel(Common.Guid.parse(elem.id), properties["type"], properties);
                    }
                    break;
                case "node":
                    graph.addNode(Common.Guid.parse(elem.id), properties["type"], Common.Guid.parse(elem["neighbours"]["models"]["parent"][0]), properties);
                    // Add Connectors
                    var connectors = elem["neighbours"]["connectors"]["child"];
                    for (var _i = 0, connectors_1 = connectors; _i < connectors_1.length; _i++) {
                        var connectorKey = connectors_1[_i];
                        var connector = jsonObject["connectors"][connectorKey];
                        var id = Common.Guid.parse(connector["id"]);
                        var connectorProperties = this.propertiesFromJSON(connector["properties"]);
                        graph.addConnector(id, connectorProperties["type"], Common.Guid.parse(elem.id), connectorProperties);
                        inQueue[id.toString()] = true;
                        var edgeIds = connector["neighbours"]["edges"]["child"];
                        var edges = [];
                        for (var _a = 0, edgeIds_1 = edgeIds; _a < edgeIds_1.length; _a++) {
                            var edgeId = edgeIds_1[_a];
                            var edge = jsonObject["edges"][edgeId];
                            var isInQueue = true;
                            for (var _b = 0, _c = edge["neighbours"]["connectors"]["parent"]; _b < _c.length; _b++) {
                                var connectorId = _c[_b];
                                if (inQueue[connectorId] !== true) {
                                    isInQueue = false;
                                }
                            }
                            if (isInQueue === true) {
                                edges.push(edgeId);
                            }
                        }
                        this.enqueueChildElement("edge", edges, queue, inQueue);
                        continue;
                    }
                    break;
                case "edge":
                    graph.addEdge(Common.Guid.parse(elem.id), properties["type"], Common.Guid.parse(elem["neighbours"]["models"]["parent"][0]), Common.Guid.parse(elem["neighbours"]["connectors"]["parent"][0]), Common.Guid.parse(elem["neighbours"]["connectors"]["parent"][1]), properties);
                    break;
                /* istanbul ignore next */
                default:
                    throw new Error("Invalid element type");
            }
            // Enqueue child elements, we directly add the connectors when processing the node
            this.enqueueChildElement("model", elem["neighbours"]["models"]["child"], queue, inQueue);
            this.enqueueChildElement("node", elem["neighbours"]["nodes"]["child"], queue, inQueue);
        }
        return graph;
    };
    /**
     * Iterate over the child elements to add them
     *
     * @param type Type of the child elements
     * @param children the Children to iterate over
     * @param queue The queue to add elements to
     * @param inQueue register which elements are processed
     */
    Graph.prototype.enqueueChildElement = function (type, children, queue, inQueue) {
        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
            var childElem = children_1[_i];
            /* istanbul ignore else */
            if (inQueue[childElem] !== true) {
                queue.enqueue({ "type": type, "element": childElem });
                inQueue[childElem] = true;
            }
        }
    };
    /**
     * Creates a Property dictionary from JSON
     *
     * @param jsonProperties JSON object that contains the properties
     */
    Graph.prototype.propertiesFromJSON = function (jsonProperties) {
        var properties = {};
        for (var propertyKey in jsonProperties) {
            properties[propertyKey] = jsonProperties[propertyKey];
        }
        return properties;
    };
    /**
     * @inheritdoc
     */
    Graph.prototype.serialize = function () {
        var graph = {
            "models": {},
            "nodes": {},
            "edges": {},
            "connectors": {}
        };
        var elements = this.elements;
        for (var key in elements) {
            var elem = elements[key];
            var obj = {
                "id": elem.Id.toString(),
                "properties": elem.getProperties(),
                "neighbours": {
                    "models": {
                        "parent": elem.getParentModelNeighbours().map(function (g) { return g.toString(); }),
                        "child": elem.getChildModelNeighbours().map(function (g) { return g.toString(); })
                    },
                    "nodes": {
                        "parent": elem.getParentNodeNeighbours().map(function (g) { return g.toString(); }),
                        "child": elem.getChildNodeNeighbours().map(function (g) { return g.toString(); })
                    },
                    "edges": {
                        "parent": elem.getParentEdgeNeighbours().map(function (g) { return g.toString(); }),
                        "child": elem.getChildEdgeNeighbours().map(function (g) { return g.toString(); })
                    },
                    "connectors": {
                        "parent": elem.getParentConnectorNeighbours().map(function (g) { return g.toString(); }),
                        "child": elem.getChildConnectorNeighbours().map(function (g) { return g.toString(); })
                    }
                }
            };
            if (elem.getType() === ElementType_1.ElementType.Node) {
                graph.nodes[elem.Id.toString()] = obj;
            }
            else if (elem.getType() === ElementType_1.ElementType.Edge) {
                graph.edges[elem.Id.toString()] = obj;
            }
            else if (elem.getType() === ElementType_1.ElementType.Connector) {
                graph.connectors[elem.Id.toString()] = obj;
            }
            else {
                graph.models[elem.Id.toString()] = obj;
            }
        }
        return graph;
    };
    return Graph;
}());
exports.Graph = Graph;
//# sourceMappingURL=Graph.js.map