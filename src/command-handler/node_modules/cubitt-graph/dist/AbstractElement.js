"use strict";
var AbstractElement = (function () {
    /**
     * @param id GUID of the Element that is created
     * @param properties of the Element
     */
    function AbstractElement(id, properties) {
        this.id = id;
        this.properties = properties;
        this.parentNodeNeighbours = {};
        this.childNodeNeighbours = {};
        this.parentEdgeNeighbours = {};
        this.childEdgeNeighbours = {};
        this.parentConnectorNeighbours = {};
        this.childConnectorNeighbours = {};
        this.parentModelNeighbours = {};
        this.childModelNeighbours = {};
    }
    Object.defineProperty(AbstractElement.prototype, "Id", {
        /**
         * Returns identifier of this element
         */
        get: function () {
            return this.id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Internal function that removes THIS element ONLY.
     * WARNING: This function does not perform a cascading delete (i.e remove orphan edges)
     * Use delete() instead
     *
     * @param graph Graph containing this element
     */
    AbstractElement.prototype.remove = function (graph) {
        graph.deleteElement(this.id);
    };
    /**
     * Adds a neighbour of type Node as *parent* to this Element
     *
     * @param id Guid of the element that should be added
     */
    AbstractElement.prototype.addParentNodeNeighbour = function (id) {
        this.parentNodeNeighbours[id.toString()] = id;
    };
    /**
     * Adds a neighbour of type Node as *child* to this Element
     *
     * @param id Guid of the element that should be added
     */
    AbstractElement.prototype.addChildNodeNeighbour = function (id) {
        this.childNodeNeighbours[id.toString()] = id;
    };
    /**
     * Adds a Neighbour of type Edge as *parent* to this Element
     *
     * @param id Guid of the element that should be added
     */
    AbstractElement.prototype.addParentEdgeNeighbour = function (id) {
        this.parentEdgeNeighbours[id.toString()] = id;
    };
    /**
     * Adds a Neighbour of type Edge as *child* to this Element
     *
     * @param id Guid of the element that should be added
     */
    AbstractElement.prototype.addChildEdgeNeighbour = function (id) {
        this.childEdgeNeighbours[id.toString()] = id;
    };
    /**
     * Adds a neighbour of type Connector as *parent* to this Element
     *
     * @param id Guid of the element that should be added
     */
    AbstractElement.prototype.addParentConnectorNeighbour = function (id) {
        this.parentConnectorNeighbours[id.toString()] = id;
    };
    /**
     * Adds a neighbour of type Connector as *child* to this Element
     *
     * @param id Guid of the element that should be added
     */
    AbstractElement.prototype.addChildConnectorNeighbour = function (id) {
        this.childConnectorNeighbours[id.toString()] = id;
    };
    /**
     * Adds a neighbour of type Model as *parent* to this Element
     *
     * @param id Guid of the element that should be added
     */
    AbstractElement.prototype.addParentModelNeighbour = function (id) {
        this.parentModelNeighbours[id.toString()] = id;
    };
    /**
     * Adds a neighbour of type Model as *child* to this Element
     *
     * @param id Guid of the element that should be added
     */
    AbstractElement.prototype.addChildModelNeighbour = function (id) {
        this.childModelNeighbours[id.toString()] = id;
    };
    /**
     * Returns all Parent neighbours of type Node
     */
    AbstractElement.prototype.getParentNodeNeighbours = function () {
        return this.toArray(this.parentNodeNeighbours);
    };
    /**
     * Returns all Child neighbours of type Node
     */
    AbstractElement.prototype.getChildNodeNeighbours = function () {
        return this.toArray(this.childNodeNeighbours);
    };
    /**
     * Returns all Parent neighbours of type Edge
     */
    AbstractElement.prototype.getParentEdgeNeighbours = function () {
        return this.toArray(this.parentEdgeNeighbours);
    };
    /**
     * Returns all Child neighbours of type Edge
     */
    AbstractElement.prototype.getChildEdgeNeighbours = function () {
        return this.toArray(this.childEdgeNeighbours);
    };
    /**
     * Returns all Parent neighbours of type Connector
     */
    AbstractElement.prototype.getParentConnectorNeighbours = function () {
        return this.toArray(this.parentConnectorNeighbours);
    };
    /**
     * Returns all Child neighbours of type Connector
     */
    AbstractElement.prototype.getChildConnectorNeighbours = function () {
        return this.toArray(this.childConnectorNeighbours);
    };
    /**
     * Returns all *Parent* neighbours of type Model
     */
    AbstractElement.prototype.getParentModelNeighbours = function () {
        return this.toArray(this.parentModelNeighbours);
    };
    /**
     * Returns all *Children* neighbous of type Model
     */
    AbstractElement.prototype.getChildModelNeighbours = function () {
        return this.toArray(this.childModelNeighbours);
    };
    /**
     * Sets a property on this Element
     *
     * @param name Name of the property to set
     * @param value desired value
     */
    AbstractElement.prototype.setProperty = function (name, value) {
        this.properties[name] = value;
    };
    /**
     * Delete a property on this Element
     *
     * @param id Identifier of the Node
     * @param name of the property
     */
    AbstractElement.prototype.deleteProperty = function (name) {
        if (name === "type") {
            throw new Error("Deleting property 'type' is not allowed");
        }
        delete this.properties[name];
    };
    /**
     * Returns all properties of this Element
     */
    AbstractElement.prototype.getProperties = function () {
        return this.properties;
    };
    /**
     * Unlink a link to a neighbouring child Node
     *
     * @param id Identifier of the child Node that should be unlinked
     */
    AbstractElement.prototype.unlinkChildNodeNeighbour = function (id) {
        delete this.childNodeNeighbours[id.toString()];
    };
    /**
     * Unlink a link to a neighbouring Child Edge
     *
     * @param id Identifier of the Child Edge that should be unlinked
     */
    AbstractElement.prototype.unlinkChildEdgeNeighbour = function (id) {
        delete this.childEdgeNeighbours[id.toString()];
    };
    /**
     * Unlink a link to a neighbouring Child Connector
     *
     * @param id Identifier of the Connector that should be unlinked
     */
    AbstractElement.prototype.unlinkChildConnectorNeighbour = function (id) {
        delete this.childConnectorNeighbours[id.toString()];
    };
    /**
     * Unlink a link to a neighbouring child Model
     *
     * @param id Identifier of the child Model that should be unlinked
     */
    AbstractElement.prototype.unlinkChildModelNeighbour = function (id) {
        delete this.childModelNeighbours[id.toString()];
    };
    /**
     * Converts a Dictionary to an Array
     *
     * @param dictionary The dictionary to convert
     */
    AbstractElement.prototype.toArray = function (dictionary) {
        var result = [];
        for (var key in dictionary) {
            var elem = dictionary[key];
            result.push(elem);
        }
        return result;
    };
    return AbstractElement;
}());
exports.AbstractElement = AbstractElement;
//# sourceMappingURL=AbstractElement.js.map